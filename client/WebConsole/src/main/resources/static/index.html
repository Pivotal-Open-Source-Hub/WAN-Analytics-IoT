<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8"/>

    <script type="text/javascript" src="d3/d3.js"></script>
    <script type="text/javascript" src="d3/d3.geom.js"></script>
    <script type="text/javascript" src="d3/d3.layout.js"></script>

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.4.2/jquery.min.js"></script>
<!-- script src="http://d3js.org/d3.v2.min.js?2.9.6"></script> -->
 
    <link type="text/css" rel="stylesheet" href="style.css"/>
    <style type="text/css">

circle {
  stroke: #000;
  stroke-opacity: .5;
}

    </style>
  </head>
  <body>
  
    <div id="body">
      <div id="footer">
        Collision Detection
        <div class="hint">move the mouse to repel nodes</div>
      </div>
    </div>  
    
    <script type="text/javascript">

var w = 1280,
    h = 800;

var svg = d3.select("#body").append("svg:svg")
.attr("width", w)
.attr("height", h);

var dataNodes;
var color;
var pis;

$.getJSON( "controller/getPIs", function(data) {
	var piNodes = d3.range(data.devices.length).map(function(i) { 
			return {
				radius: 100, 
				name: data.devices[i].deviceId,
				x: data.devices[i].x, 
				y: data.devices[i].x
			};
		});
	color = d3.scale.category10();                
	pis = piNodes;
	
	svg
	.selectAll("circle")
    .data(piNodes)
		.enter()
		.append("svg:circle")
 	  	.attr("stroke-width", "3")
  	 	.attr("stroke-dasharray", "5,5")
   		.attr("fill-opacity", 0.0)		
	    .attr("r", function(d) { return 100; })
	    .attr("cx", function(d) { return d.x; })
	    .attr("cy", function(d) { return d.y; });
	
	
});


$.getJSON( "controller/getDeviceMap", function(data) {
		var nodes = d3.range(data.devices.length).map(function(i) { 
				return {
					radius: Math.random() * 12 + 4, 
					name: data.devices[i].deviceId,
					x: data.devices[i].x, 
					y: data.devices[i].x
				};
			});
		
		color = d3.scale.category10();                
	
		dataNodes = nodes;
		
		svg
			.selectAll("circle")
		    .data(nodes)
   			.enter()
	   		.append("svg:circle")
			    .attr("r", function(d) { return d.radius - 2; })
			    .attr("cx", function(d) { return d.x; })
			    .attr("cy", function(d) { return d.y; })
			    .style("fill", function(d, i) { return color(i % 3); });

		
});
		
	
var updateData = function() {
      
	
	
	$.getJSON( "controller/getDeviceMap", function(data) {
		var nodes = d3.range(data.devices.length).map(function(i) { 
				return {
					radius: Math.random() * 12 + 4, 
					name: data.devices[i].deviceId,
					x: data.devices[i].x, 
					y: data.devices[i].x
				};
			});
		
		color = d3.scale.category10();
		
		dataNodes = nodes;
		
		var duration = 200;
		var delay = 0;
		
		var vis = svg.selectAll('circle')
		  .data(dataNodes, function(d) { return d.name; });
		
		
		 
		// update - This only applies to updating nodes
		vis
		  .transition()
		  .duration(duration)
		  .delay(function(d, i) {delay = i * 7; return delay;}) 
		  .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
		  .attr('r', function(d) { return d.r; })
		 
		// enter
		vis		
		  .enter()
		  .append('svg:circle')
		  .attr("r", function(d) { return d.radius - 2; })
		  .attr("cx", function(d) { return d.x; })
		  .attr("cy", function(d) { return d.y; })
		  .style("fill", function(d, i) { return color(i % 3); })
		  .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
		  .style('opacity', 0) 
		  .transition()
		  .duration(duration * 1.2)
			.style('opacity', 1);
		 
		// exit
		/*
		vis
		  .exit()
		  .transition()
		  .duration(duration + delay)
		  .style('opacity', 0)
		  .remove();	
		*/

		
	});
    setTimeout(updateData, 2000);
    
};


setTimeout(updateData, 2000);



           	  

	
   	
 





function collide(node) {
var r = node.radius + 16,
  nx1 = node.x - r,
  nx2 = node.x + r,
  ny1 = node.y - r,
  ny2 = node.y + r;
return function(quad, x1, y1, x2, y2) {
if (quad.point && (quad.point !== node)) {
  var x = node.x - quad.point.x,
      y = node.y - quad.point.y,
      l = Math.sqrt(x * x + y * y),
      r = node.radius + quad.point.radius;
  if (l < r) {
    l = (l - r) / l * .5;
    node.x -= x *= l;
    node.y -= y *= l;
    quad.point.x += x;
    quad.point.y += y;
  }
}
return x1 > nx2
    || x2 < nx1
    || y1 > ny2
    || y2 < ny1;
};




}
</script>
</body>
</html>    
    
    
    
    
